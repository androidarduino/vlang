# C 编译器开发路线图

## 当前状态 ✅
- [x] 词法分析 (Lexical Analysis)
- [x] 语法分析 (Syntax Analysis)  
- [x] AST 构建 (Abstract Syntax Tree)

## 第一阶段：语义分析 (Semantic Analysis)

### 1. 符号表管理 (Symbol Table) - 最关键！
**目标**：跟踪程序中所有标识符的信息

**需要实现**：
```
符号表结构：
├── 变量信息：名称、类型、作用域、内存地址
├── 函数信息：名称、返回类型、参数列表
├── 作用域管理：全局作用域、函数作用域、块作用域
└── 符号查找：支持嵌套作用域的查找
```

**功能**：
- 插入符号 `symbol_table_insert(name, type, scope)`
- 查找符号 `symbol_table_lookup(name)`
- 进入/退出作用域 `enter_scope()` / `exit_scope()`
- 类型信息存储

**预计工作量**：2-3 天

---

### 2. 类型检查 (Type Checking)
**目标**：确保所有操作类型兼容

**需要检查**：
- 变量声明时的类型
- 表达式中的类型匹配（如：不能用 int + string）
- 函数调用的参数类型
- 赋值语句的类型兼容性
- 返回值类型

**示例错误检测**：
```c
int x = "hello";  // 错误：类型不匹配
int y = x + z;    // 错误：z 未声明
return "test";    // 错误：返回类型不匹配
```

**预计工作量**：2-3 天

---

### 3. 语义检查
**目标**：检查其他语义规则

- 变量使用前必须声明
- 函数使用前必须声明或定义
- break/continue 只能在循环中使用
- 数组下标必须是整数
- 函数调用参数数量匹配

**预计工作量**：1-2 天

---

## 第二阶段：中间代码生成 (IR Generation)

### 4. 三地址码 (Three-Address Code)
**目标**：将 AST 转换为简单的中间表示

**示例转换**：
```c
// 源代码
int x = a + b * c;

// 三地址码
t1 = b * c
t2 = a + t1
x = t2
```

**数据结构**：
```c
typedef enum {
    IR_ADD, IR_SUB, IR_MUL, IR_DIV,
    IR_ASSIGN, IR_LABEL, IR_GOTO,
    IR_IF_FALSE, IR_PARAM, IR_CALL, IR_RETURN
} IROpcode;

typedef struct {
    IROpcode op;
    char *result;
    char *arg1;
    char *arg2;
} IRInstruction;
```

**预计工作量**：3-4 天

---

### 5. 控制流图 (Control Flow Graph)
**目标**：表示程序的控制流

- 基本块 (Basic Blocks) 识别
- 跳转和分支的表示
- 为优化做准备

**预计工作量**：2 天

---

## 第三阶段：代码优化 (Optimization)

### 6. 局部优化
- 常量折叠：`x = 2 + 3` → `x = 5`
- 常量传播：传播常量值
- 代数简化：`x * 1` → `x`
- 死代码消除：删除永不执行的代码

**预计工作量**：2-3 天

---

### 7. 全局优化 (可选)
- 公共子表达式消除
- 循环优化
- 数据流分析

**预计工作量**：3-5 天

---

## 第四阶段：目标代码生成 (Code Generation)

### 8. 指令选择
**目标**：将 IR 映射到目标机器指令

**选择目标平台**：
- x86-64 汇编（推荐）
- LLVM IR（高级选择）
- 自定义虚拟机字节码（简化选择）

**预计工作量**：4-5 天

---

### 9. 寄存器分配
**目标**：分配有限的寄存器给变量

- 简单方案：基于栈的分配
- 高级方案：图着色算法

**预计工作量**：3-4 天

---

### 10. 代码发射 (Code Emission)
**目标**：生成最终的汇编代码或机器码

- 生成汇编文件 `.s`
- 使用系统汇编器和链接器生成可执行文件

**预计工作量**：2-3 天

---

## 总体时间估算

### 最小可行编译器 (MVP)
- 符号表 + 类型检查 + 简单 IR + 栈式代码生成
- **预计：2-3 周**

### 完整功能编译器
- 包含优化和寄存器分配
- **预计：1-2 个月**

### 生产级编译器
- 完整的 C 语言支持 + 高级优化
- **预计：3-6 个月**

---

## 推荐的开发顺序

### Phase 1: 符号表 + 类型检查（立即开始）
这是最关键的一步，没有它就无法进行后续工作。

**为什么先做这个？**
1. 必须知道每个标识符的类型才能生成正确的代码
2. 必须检测语义错误（未声明的变量等）
3. 为后续阶段提供必要的类型信息

### Phase 2: 简化的代码生成器（快速原型）
可以先实现一个简单的基于栈的虚拟机或者直接生成简单的汇编。

### Phase 3: 逐步增强
添加优化、改进代码生成等。

---

## 第一步：实现符号表

我建议从以下开始：

1. **创建 `symbol_table.h` 和 `symbol_table.c`**
   - 定义符号表数据结构
   - 实现基本操作（插入、查找）
   
2. **添加遍历 AST 的函数**
   - 第一遍：收集所有声明
   - 第二遍：检查所有使用

3. **集成到编译器**
   - 在 AST 构建后调用语义分析
   - 输出符号表内容（用于调试）

是否需要我立即开始实现符号表？
