# C ç¼–è¯‘å™¨æ¶æ„

## å®Œæ•´çš„ç¼–è¯‘å™¨æµç¨‹

```
æºä»£ç  (source.c)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 1: è¯æ³•åˆ†æ (Lexer)                          â”‚ âœ… å·²å®Œæˆ
â”‚  ãƒ»å°†æºä»£ç åˆ†è§£ä¸º tokens                           â”‚
â”‚  ãƒ»è¯†åˆ«å…³é”®å­—ã€æ ‡è¯†ç¬¦ã€å­—é¢é‡ã€è¿ç®—ç¬¦              â”‚
â”‚  è¾“å…¥: "int x = 10;"                               â”‚
â”‚  è¾“å‡º: [INT, IDENTIFIER, ASSIGN, INT_CONST, SEMI]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 2: è¯­æ³•åˆ†æ (Parser)                         â”‚ âœ… å·²å®Œæˆ
â”‚  ãƒ»éªŒè¯ token åºåˆ—çš„è¯­æ³•æ­£ç¡®æ€§                     â”‚
â”‚  ãƒ»æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ (AST)                            â”‚
â”‚  è¾“å…¥: token æµ                                    â”‚
â”‚  è¾“å‡º: AST                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 3: è¯­ä¹‰åˆ†æ (Semantic Analysis)              â”‚ â³ ä¸‹ä¸€æ­¥
â”‚  ãƒ»æ„å»ºç¬¦å·è¡¨                                      â”‚
â”‚  ãƒ»ç±»å‹æ£€æŸ¥                                        â”‚
â”‚  ãƒ»ä½œç”¨åŸŸåˆ†æ                                      â”‚
â”‚  ãƒ»æ£€æµ‹è¯­ä¹‰é”™è¯¯                                    â”‚
â”‚  è¾“å…¥: AST                                         â”‚
â”‚  è¾“å‡º: å¸¦ç±»å‹ä¿¡æ¯çš„ AST + ç¬¦å·è¡¨                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 4: ä¸­é—´ä»£ç ç”Ÿæˆ (IR Generation)              â”‚ ğŸ”œ æœªæ¥
â”‚  ãƒ»å°† AST è½¬æ¢ä¸ºä¸‰åœ°å€ç                            â”‚
â”‚  ãƒ»ç®€åŒ–å¤æ‚è¡¨è¾¾å¼                                  â”‚
â”‚  ãƒ»è§„èŒƒåŒ–æ§åˆ¶æµ                                    â”‚
â”‚  è¾“å…¥: å¸¦ç±»å‹çš„ AST                                â”‚
â”‚  è¾“å‡º: ä¸­é—´è¡¨ç¤º (IR)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 5: ä»£ç ä¼˜åŒ– (Optimization)                   â”‚ ğŸ”œ æœªæ¥
â”‚  ãƒ»å¸¸é‡æŠ˜å                                         â”‚
â”‚  ãƒ»æ­»ä»£ç æ¶ˆé™¤                                      â”‚
â”‚  ãƒ»å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤                                â”‚
â”‚  è¾“å…¥: IR                                          â”‚
â”‚  è¾“å‡º: ä¼˜åŒ–çš„ IR                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 6: ç›®æ ‡ä»£ç ç”Ÿæˆ (Code Generation)            â”‚ ğŸ”œ æœªæ¥
â”‚  ãƒ»æŒ‡ä»¤é€‰æ‹©                                        â”‚
â”‚  ãƒ»å¯„å­˜å™¨åˆ†é…                                      â”‚
â”‚  ãƒ»ç”Ÿæˆæ±‡ç¼–ä»£ç                                     â”‚
â”‚  è¾“å…¥: ä¼˜åŒ–çš„ IR                                   â”‚
â”‚  è¾“å‡º: æ±‡ç¼–ä»£ç  (.s)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µ 7: æ±‡ç¼–å’Œé“¾æ¥                                â”‚ ğŸ”œ æœªæ¥
â”‚  ãƒ»è°ƒç”¨ç³»ç»Ÿæ±‡ç¼–å™¨ (as)                             â”‚
â”‚  ãƒ»è°ƒç”¨é“¾æ¥å™¨ (ld)                                 â”‚
â”‚  è¾“å…¥: æ±‡ç¼–ä»£ç                                     â”‚
â”‚  è¾“å‡º: å¯æ‰§è¡Œæ–‡ä»¶                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
å¯æ‰§è¡Œæ–‡ä»¶ (a.out)
```

## å…³é”®æ•°æ®ç»“æ„

### å½“å‰å·²æœ‰
```c
// Token (Lexer è¾“å‡º)
typedef struct {
    TokenType type;
    char *value;
    int lineno;
} Token;

// AST Node (Parser è¾“å‡º)
typedef struct ASTNode {
    ASTNodeType type;
    int lineno;
    struct ASTNode **children;
    int num_children;
    union {
        int int_val;
        float float_val;
        char *string_val;
        OperatorType op_type;
    } value;
    void *semantic_info;  // å°†åœ¨è¯­ä¹‰åˆ†æé˜¶æ®µå¡«å……
} ASTNode;
```

### éœ€è¦æ·»åŠ  (ä¸‹ä¸€æ­¥)
```c
// ç±»å‹ç³»ç»Ÿ
typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_CHAR,
    TYPE_VOID,
    TYPE_POINTER,
    TYPE_ARRAY,
    TYPE_FUNCTION
} DataType;

typedef struct TypeInfo {
    DataType base_type;
    int pointer_level;      // æŒ‡é’ˆå±‚çº§
    int array_size;         // æ•°ç»„å¤§å°
    struct TypeInfo *return_type;  // å‡½æ•°è¿”å›ç±»å‹
    struct TypeInfo **param_types; // å‡½æ•°å‚æ•°ç±»å‹
    int num_params;
} TypeInfo;

// ç¬¦å·è¡¨é¡¹
typedef struct Symbol {
    char *name;
    TypeInfo *type;
    int scope_level;
    int offset;             // ç›¸å¯¹äºåŸºå€çš„åç§»
    int is_function;
    ASTNode *declaration;   // æŒ‡å‘å£°æ˜èŠ‚ç‚¹
} Symbol;

// ä½œç”¨åŸŸ
typedef struct Scope {
    Symbol **symbols;
    int num_symbols;
    int capacity;
    struct Scope *parent;   // çˆ¶ä½œç”¨åŸŸ
} Scope;

// ç¬¦å·è¡¨
typedef struct SymbolTable {
    Scope *current_scope;
    Scope *global_scope;
    int current_level;
} SymbolTable;
```

### æœªæ¥éœ€è¦ (ä¸­é—´ä»£ç )
```c
// ä¸‰åœ°å€ç æŒ‡ä»¤
typedef enum {
    IR_ADD, IR_SUB, IR_MUL, IR_DIV,
    IR_ASSIGN, IR_LABEL, IR_GOTO,
    IR_IF_FALSE, IR_PARAM, IR_CALL, IR_RETURN
} IROpcode;

typedef struct IRInstruction {
    IROpcode op;
    char *result;
    char *arg1;
    char *arg2;
    int label;
} IRInstruction;

// IR ç¨‹åº
typedef struct IRProgram {
    IRInstruction **instructions;
    int num_instructions;
    int next_temp;    // ä¸´æ—¶å˜é‡è®¡æ•°å™¨
    int next_label;   // æ ‡ç­¾è®¡æ•°å™¨
} IRProgram;
```

## ä¸‹ä¸€æ­¥å®æ–½è®¡åˆ’

### ç«‹å³å¼€å§‹ï¼šç¬¦å·è¡¨å®ç°

#### ç¬¬ 1 å¤©ï¼šåŸºç¡€è®¾æ–½
```c
1. åˆ›å»º symbol_table.h å’Œ symbol_table.c
2. å®ç°ç±»å‹ç³»ç»Ÿ (TypeInfo)
3. å®ç°ç¬¦å·è¡¨åŸºæœ¬æ“ä½œï¼š
   - symbol_table_init()
   - symbol_table_insert()
   - symbol_table_lookup()
   - enter_scope() / exit_scope()
```

#### ç¬¬ 2 å¤©ï¼šAST éå†
```c
1. åˆ›å»º semantic.h å’Œ semantic.c
2. å®ç° AST éå†å‡½æ•°ï¼š
   - analyze_program(AST)
   - analyze_function(AST)
   - analyze_declaration(AST)
   - analyze_statement(AST)
   - analyze_expression(AST)
```

#### ç¬¬ 3 å¤©ï¼šç±»å‹æ£€æŸ¥
```c
1. ä¸ºæ¯ä¸ª AST èŠ‚ç‚¹æ¨å¯¼ç±»å‹
2. æ£€æŸ¥ç±»å‹å…¼å®¹æ€§ï¼š
   - check_binary_expr_types()
   - check_assignment_types()
   - check_function_call_types()
```

#### ç¬¬ 4 å¤©ï¼šé”™è¯¯æŠ¥å‘Š
```c
1. å®ç°å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
2. é›†æˆåˆ°ç¼–è¯‘å™¨ä¸»æµç¨‹
3. æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µ
```

### ç¤ºä¾‹ï¼šç¬¦å·è¡¨çš„ä½¿ç”¨

```c
// è¾“å…¥ç¨‹åº
int x;
int main() {
    float y;
    x = 10;      // OK: x æ˜¯å…¨å±€ int
    y = 3.14;    // OK: y æ˜¯å±€éƒ¨ float
    z = 5;       // ERROR: z æœªå£°æ˜
    y = x + 1;   // OK: ç±»å‹å…¼å®¹
}

// ç¬¦å·è¡¨å†…å®¹
Global Scope:
  - x: int, offset=0
  - main: function()->int
    Local Scope (main):
      - y: float, offset=-4

// é”™è¯¯æ£€æµ‹
Error at line 5: Undeclared variable 'z'
```

## å·¥å…·å’Œæ–‡ä»¶ç»„ç»‡

### å½“å‰æ–‡ä»¶ç»“æ„
```
compiler/
â”œâ”€â”€ ast.h / ast.c              âœ… AST å®šä¹‰
â”œâ”€â”€ c_lexer_ast.l              âœ… Lexer
â”œâ”€â”€ c_parser_ast.y             âœ… Parser
â””â”€â”€ c_compiler_ast             âœ… ç¼–è¯‘å™¨å¯æ‰§è¡Œæ–‡ä»¶
```

### ä¸‹ä¸€æ­¥æ·»åŠ 
```
compiler/
â”œâ”€â”€ ast.h / ast.c
â”œâ”€â”€ c_lexer_ast.l
â”œâ”€â”€ c_parser_ast.y
â”œâ”€â”€ symbol_table.h / symbol_table.c  â³ æ–°å¢
â”œâ”€â”€ semantic.h / semantic.c          â³ æ–°å¢
â”œâ”€â”€ types.h                          â³ æ–°å¢
â””â”€â”€ error.h / error.c                â³ æ–°å¢
```

### æœªæ¥æ·»åŠ 
```
compiler/
â”œâ”€â”€ ... (ä¸Šè¿°æ–‡ä»¶)
â”œâ”€â”€ ir_gen.h / ir_gen.c       ğŸ”œ ä¸­é—´ä»£ç ç”Ÿæˆ
â”œâ”€â”€ optimizer.h / optimizer.c  ğŸ”œ ä¼˜åŒ–å™¨
â”œâ”€â”€ codegen.h / codegen.c      ğŸ”œ ä»£ç ç”Ÿæˆ
â””â”€â”€ Makefile                   ğŸ”œ æ„å»ºç³»ç»Ÿ
```

## æµ‹è¯•é©±åŠ¨å¼€å‘

### æµ‹è¯•ç”¨ä¾‹ 1: ç®€å•å£°æ˜
```c
int x;
int main() {
    x = 10;
    return 0;
}
// é¢„æœŸï¼šç¬¦å·è¡¨åŒ…å« x å’Œ mainï¼Œæ— é”™è¯¯
```

### æµ‹è¯•ç”¨ä¾‹ 2: æœªå£°æ˜å˜é‡
```c
int main() {
    x = 10;  // é”™è¯¯
    return 0;
}
// é¢„æœŸï¼šé”™è¯¯ "Undeclared variable 'x'"
```

### æµ‹è¯•ç”¨ä¾‹ 3: ç±»å‹ä¸åŒ¹é…
```c
int main() {
    int x;
    x = 3.14;  // è­¦å‘Šæˆ–é”™è¯¯
    return 0;
}
// é¢„æœŸï¼šè­¦å‘Š "Type mismatch in assignment"
```

---

## å‡†å¤‡å¥½å¼€å§‹äº†å—ï¼Ÿ

æˆ‘å¯ä»¥ç«‹å³å¼€å§‹å®ç°ç¬¦å·è¡¨å’Œè¯­ä¹‰åˆ†æã€‚è¿™å°†ä½¿æ‚¨çš„ç¼–è¯‘å™¨èƒ½å¤Ÿï¼š

âœ… æ£€æµ‹æœªå£°æ˜çš„å˜é‡
âœ… æ£€æµ‹ç±»å‹é”™è¯¯
âœ… ç®¡ç†ä½œç”¨åŸŸ
âœ… ä¸ºä»£ç ç”Ÿæˆå‡†å¤‡ç±»å‹ä¿¡æ¯

éœ€è¦æˆ‘ç°åœ¨å¼€å§‹å®ç°å—ï¼Ÿ
